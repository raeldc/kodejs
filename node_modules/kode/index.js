// Execute this script only once
if (typeof kode !== 'undefined') return;

var util = require('util');

var Kode = function()
{
    this.objectRegistry = [];
}

Kode.prototype.getObject = function(identifier, config)
{
    var object = this.objectRegistry[identifier];

    if (object !== undefined) {
        objectConfig = (identifier === 'lib:object.config') ? config : this.getObject('lib:object.config', config);
        return new object.CLASS(objectConfig);
    }

    return {};
}

Kode.prototype.defineObject = function(identifier, parent, definition)
{
    // Don't define if already defined
    if (identifier === undefined || this.objectRegistry[identifier] !== undefined) return;

    // Initialize the object with a default property CLASS
    var object = {
        CLASS: function() 
        {
            if(typeof this.init === 'function'){
                var config = arguments[0] instanceof Object ? arguments[0] : {};
                this.init.apply(this, [config]);
            }
        }
    };

    // Make sure definition is an object
    definition = definition || {};

    // If parent is an identifier
    if (typeof parent === 'string') {
        if (this.objectRegistry[parent] === undefined) {
            throw new ReferenceError('Object is not defined: ' + parent);
        }

        parent = this.objectRegistry[parent];
    } else {
        definition = parent instanceof Object ? parent : {};

        // Parent is Object
        parent = {
            CLASS     : Object,
            definition: {}
        }
    } 

    if (definition instanceof Object) {
        // Copy the definition into the prototype
        for (var method in definition) {
            // If method exists both in definition and parent
            if (typeof definition[method] === 'function' && typeof parent.definition[method] === 'function') {
                // Create a wrapper function that binds the `parentMethod` to `this`
                object.CLASS.prototype[method] = (function(childMethod, parentMethod){
                    return function(){
                        this.parentMethod = parentMethod;
                        var result = childMethod.apply(this, arguments);
                        this.parentMethod = undefined;
                        return result;
                    }
                })(definition[method], parent.definition[method]);
                continue;
            }

            // If method exists only in the definition
            if (typeof definition[method] === 'function') {
                object.CLASS.prototype[method] = definition[method];
                continue;
            }
        }

        // Copy the parent definition into the object prototype
        for (var method in parent.definition) {
            // If method doesn't exist yet in the object and if the prototype method is a function
            if (typeof object.CLASS.prototype[method] === 'undefined' && typeof parent.definition[method] === 'function') {
                object.CLASS.prototype[method] = parent.definition[method];
            }
        }
    }

    // These can't be overriden by the definition
    object.identifier                 = identifier;
    object.definition                 = object.CLASS.prototype;
    object.CLASS.prototype.parent     = parent.CLASS;
    object.CLASS.prototype.identifier = identifier;

    this.objectRegistry[identifier] = object;

    return this.objectRegistry[identifier];
}

GLOBAL.kode         = new Kode();
GLOBAL.getObject    = GLOBAL.kode.getObject.bind(GLOBAL.kode);
GLOBAL.defineObject = GLOBAL.kode.defineObject.bind(GLOBAL.kode);

// Include most commonly used objects
require('kode/lib/object/config');